# 了解HTTP和HTTPS
　超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

## 一、HTTP和HTTPS的基本概念

　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

## 二、http协议的特点有哪些？

 http协议的特点总结起来就一下几点：

 1、http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。

 2、无连接。所谓的无连接就是服务器收到了客户端的请求之后，响应完成并收到客户端的应答之后，即断开连接。限制每次的连接只处理一次请求。从而节省传输时间。

 3、无状态。http协议对事务的处理没有记忆能力。也就意味着如果需要前面的信息，只能重传，这无形之中增加数据的传输量。这种方式某种方面上讲解放了服务器，但是却不利于客户端与服务器的连接。为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session，后面我们再细讲它们。

 4、简单快捷：所谓的简单快捷是指客户端向服务器请求服务时，一般来说只需要传输请求方法和路径，就能进行访问。

 5、灵活：这里主要指的是客户端可以通过http协议传输任意类型的数据。比如传输.jpg文件、.ppt文件等等，只需要设定content-type就可以进行传输。至于content-type是什么，咱们后面再细讲。
## 三、HTTP与HTTPS有什么区别？

　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
### HTTPS和HTTP的区别主要如下：
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
## 四、https请求/响应的步骤是什么？
客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

　　（5）Web服务器利用自己的私钥解密出会话密钥。

　　（6）Web服务器利用会话密钥加密与客户端之间的通信。
[https请求步骤图](https://pic002.cnblogs.com/images/2012/339704/2012071410212142.gif)
## 五、HTTP请求方法有哪些
- Get 方法：发送一个请求来获取服务器资源
- POST 方法：向服务器提交数据
- PUT 方法：与POST方法很像，也是提交数据，但PUT制定了资源在服务器上的位置，常用在修改数据
- HEAD 方法：只请求页面的首部信息
- DELETE 方法：删除服务器上的资源
- OPTIONS 方法：用于获取当前URL支持的请求方式
- TRACE 方法：用于激活一个远程的应用层请求消息回路
- CONNECT 方法：把请求链接转换到透明的TCP/IP的通道
## 六、HTTP1.0和HTTP2.0的区别
总的区别就是：
- HTTP/2采用二进制格式而非文本格式
- HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
- 使用报头压缩，HTTP/2降低了开销
- HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

## 七、HTTP状态码 
- 1##：请求收到，继续处理
  - 100——客户必须继续发出请求
  - 101——客户要求服务器根据请求转换HTTP协议版本
- 2##：操作成功收到，分析、接受
  - 200——成功请求页面
  - 201——提示知道新文件的URL
  - 202——接受和处理、但处理未完成
  - 203——返回信息不确定或不完整
  - 204——请求收到，但返回信息为空
  - 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
  - 206——服务器已经完成了部分用户的GET请求
- 3##：完成此请求必须进一步处理
  - 300——请求的资源可在多处得到
  - 301——删除请求数据
  - 302——在其他地址发现了请求数据
  - 303——建议客户访问其他URL或访问方式
  - 304——客户端已经执行了GET，但文件未变化 304状态码或许不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。
  - 305——请求的资源必须从服务器指定的地址得到
  - 306——前一版本HTTP中使用的代码，现行版本中不再使用
  - 307——申明请求的资源临时性删除
- 4##：请求包含一个错误语法或不能完成
  - 400——错误请求，如语法错误
  - 401——请求授权失败
  - 402——保留有效ChargeTo头响应
  - 403——请求不允许 
  - 404——没有发现文件、查询或URl
  - 405——用户在Request-Line字段定义的方法不允许
  - 406——根据用户发送的Accept拖，请求资源不可访问
  - 407——类似401，用户必须首先在代理服务器上得到授权
  - 408——客户端没有在用户指定的饿时间内完成请求
  - 409——对当前资源状态，请求不能完成
  - 410——服务器上不再有此资源且无进一步的参考地址
  - 411——服务器拒绝用户定义的Content-Length属性请求
  - 412——一个或多个请求头字段在当前请求中错误
  - 413——请求的资源大于服务器允许的大小
  - 414——请求的资源URL长于服务器允许的长度
  - 415——请求资源不支持请求项目格式
  - 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range 请求头字段
  - 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
- 5##：服务器执行一个完全有效请求失败
  - 500——服务器产生内部错误
  - 501——服务器不支持请求的函数 
  - 502——服务器暂时不可用，有时是为了防止发生系统过载
  - 503——服务器过载或暂停维修
  - 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
  - 505——服务器不支持或拒绝支请求头中指定的HTTP版本


## 了解HTTP缓存
Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。

### 缓存优点：
- 减少不必要的数据传输，节省带宽
- 减少服务器负担，提升网站性能
- 加快客户端加载网页的速度，用户体验友好
### 缓存缺点：
- 服务端资源更新后，客户端更新滞后
### 浏览器缓存主要有两类：强制缓存、协商缓存
## 两种缓存的共同点：都从客户端缓存中读取资源；区别是强缓存不会向服务器发请求，协商缓存会发请求
### 强制缓存
不会向服务器发送请求，直接从缓存中读取资源，请求返回状态码为 200 ;

强制缓存时，服务端会在 Response Headers 中的 cache-control 对缓存时间、缓存方式等进行定义
####  cache-control 字段
- cache-control: max-age=xxxx，public
  - 客户端和代理服务器都可以缓存该资源；
  - 客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存, statu code: 200
  - 如果用户做了刷新操作，就向服务器发起http请求
- cache-control: max-age=xxxx，private
  - 只允许客户端可以缓存该资源；代理服务器不允许缓存
  - 客户端在xxx秒内直接读取缓存, statu code: 200
- cache-control: max-age=xxxx，immutable
  - 客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存, statu code:200
  - 即使用户做了刷新操作，也不向服务器发起http请求
- cache-control: no-cache
  - 跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
- cache-control: no-store
  - 不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。

### 协商缓存
向服务器发送请求，服务器会根据这个请求的 Request Headers 的一些参数(etag 和 last-modified)来判断是否命中协商缓存，如果命中，则返回 304 状态码, 并带上新的 Request Headers 通知浏览器从缓存中读取资源；

协商缓存主要表现在 Response Headers 中的 etag 和 last-modified：
#### etag：即文件hash，每个文件唯一
#### last-modified：文件的修改时间，精确到秒


# 浏览器的缓存过程是：

- 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
- 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；
- 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；
- 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200。
[缓存过程图解](https://mmbiz.qpic.cn/mmbiz_png/83d3vL8fIicaLbdP0icWia9aMpmEQpgfNibdsoEyzvKKyIXFpISet9SVWxx1Uwz2WCZfdsMkib0VIeCbkCHrvtEkyBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)